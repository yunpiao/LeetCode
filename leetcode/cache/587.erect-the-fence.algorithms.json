{"id":587,"fid":"587","name":"安装栅栏","slug":"erect-the-fence","link":"https://leetcode.cn/problems/erect-the-fence/description/","percent":59.96736128546322,"level":"Hard","category":"algorithms","en_name":"Erect the Fence","cn_name":"安装栅栏","totalAC":"19.4K","totalSubmit":"32.4K","likes":236,"dislikes":0,"desc":"<p>给定一个数组 <code>trees</code>，其中 <code>trees[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示树在花园中的位置。</p>\n\n<p>你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把&nbsp;<strong>所有的树都围起来</strong>，花园才围得很好。</p>\n\n<p>返回<em>恰好位于围栏周边的树木的坐标</em>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg\" style=\"width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>输出:</strong> [[1,1],[2,0],[3,3],[2,4],[4,2]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg\" style=\"height: 393px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,2],[2,2],[4,2]]\n<strong>输出:</strong> [[4,2],[2,2],[1,2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 3000</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n\t<li>\n\t<p data-group=\"1-1\">所有给定的点都是&nbsp;<strong>唯一&nbsp;</strong>的。</p>\n\t</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\n        \n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public int[][] outerTrees(int[][] trees) {\n        \n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def outerTrees(self, trees):\n        \"\"\"\n        :type trees: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:\n        "},{"value":"c","text":"C","defaultCode":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** outerTrees(int** trees, int treesSize, int* treesColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public int[][] OuterTrees(int[][] trees) {\n        \n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number[][]} trees\n * @return {number[][]}\n */\nvar outerTrees = function(trees) {\n    \n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function outerTrees(trees: number[][]): number[][] {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param Integer[][] $trees\n     * @return Integer[][]\n     */\n    function outerTrees($trees) {\n        \n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func outerTrees(_ trees: [[Int]]) -> [[Int]] {\n        \n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {\n        \n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<List<int>> outerTrees(List<List<int>> trees) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func outerTrees(trees [][]int) [][]int {\n    \n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer[][]} trees\n# @return {Integer[][]}\ndef outer_trees(trees)\n    \nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def outerTrees(trees: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn outer_trees(trees: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (outer-trees trees)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec outer_trees(Trees :: [[integer()]]) -> [[integer()]].\nouter_trees(Trees) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec outer_trees(trees :: [[integer]]) :: [[integer]]\n  def outer_trees(trees) do\n    \n  end\nend"},{"value":"cangjie","text":"Cangjie","defaultCode":"class Solution {\n    func outerTrees(trees: Array<Array<Int64>>): Array<Array<Int64>> {\n\n    }\n}"}],"testcase":"[[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]","testable":true,"templateMeta":{"name":"outerTrees","params":[{"name":"trees","type":"integer[][]"}],"return":{"type":"integer[][]"}}}