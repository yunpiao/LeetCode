{"id":332,"fid":"332","name":"重新安排行程","slug":"reconstruct-itinerary","link":"https://leetcode.cn/problems/reconstruct-itinerary/description/","percent":44.37359506799314,"level":"Hard","category":"algorithms","en_name":"Reconstruct Itinerary","cn_name":"重新安排行程","totalAC":"123.2K","totalSubmit":"278.8K","likes":960,"dislikes":0,"desc":"<p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>\n\n<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>\n\n<ul>\n\t<li>例如，行程 <code>[\"JFK\", \"LGA\"]</code> 与 <code>[\"JFK\", \"LGB\"]</code> 相比就更小，排序更靠前。</li>\n</ul>\n\n<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg\" style=\"width: 382px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n<strong>输出：</strong>[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg\" style=\"width: 222px; height: 230px;\" />\n<pre>\n<strong>输入：</strong>tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n<strong>输出：</strong>[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n<strong>解释：</strong>另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] ，但是它字典排序更大更靠后。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= tickets.length <= 300</code></li>\n\t<li><code>tickets[i].length == 2</code></li>\n\t<li><code>from<sub>i</sub>.length == 3</code></li>\n\t<li><code>to<sub>i</sub>.length == 3</code></li>\n\t<li><code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 由大写英文字母组成</li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        \n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        \n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        "},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        "},{"value":"c","text":"C","defaultCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** findItinerary(char*** tickets, int ticketsSize, int* ticketsColSize, int* returnSize) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\n        \n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {string[][]} tickets\n * @return {string[]}\n */\nvar findItinerary = function(tickets) {\n    \n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function findItinerary(tickets: string[][]): string[] {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param String[][] $tickets\n     * @return String[]\n     */\n    function findItinerary($tickets) {\n        \n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func findItinerary(_ tickets: [[String]]) -> [String] {\n        \n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun findItinerary(tickets: List<List<String>>): List<String> {\n        \n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<String> findItinerary(List<List<String>> tickets) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func findItinerary(tickets [][]string) []string {\n    \n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {String[][]} tickets\n# @return {String[]}\ndef find_itinerary(tickets)\n    \nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def findItinerary(tickets: List[List[String]]): List[String] = {\n        \n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\n        \n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (find-itinerary tickets)\n  (-> (listof (listof string?)) (listof string?))\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec find_itinerary(Tickets :: [[unicode:unicode_binary()]]) -> [unicode:unicode_binary()].\nfind_itinerary(Tickets) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec find_itinerary(tickets :: [[String.t]]) :: [String.t]\n  def find_itinerary(tickets) do\n    \n  end\nend"},{"value":"cangjie","text":"Cangjie","defaultCode":"class Solution {\n    func findItinerary(tickets: ArrayList<ArrayList<String>>): ArrayList<String> {\n\n    }\n}"}],"testcase":"[[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]","testable":true,"templateMeta":{"name":"findItinerary","params":[{"name":"tickets","type":"list<list<string>>"}],"return":{"type":"list<string>"}}}